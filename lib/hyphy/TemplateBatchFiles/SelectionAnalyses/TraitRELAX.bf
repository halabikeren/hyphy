RequireVersion("2.3.1");

/* _______________________________ IMPORTS _______________________________ */

LoadFunctionLibrary("libv3/all-terms.bf"); 				  // must be loaded before CF3x4
LoadFunctionLibrary("libv3/UtilityFunctions.bf"); 		  // namespace 'utility' for convenience functions
LoadFunctionLibrary("libv3/IOFunctions.bf");			  // namespace 'io' for interactive/datamonkey i/o functions
LoadFunctionLibrary ("libv3/models/codon/MG_REV.bf");
LoadFunctionLibrary("libv3/tasks/estimators.bf");
LoadFunctionLibrary("libv3/tasks/alignments.bf");
LoadFunctionLibrary("libv3/tasks/trees.bf");
LoadFunctionLibrary("libv3/tasks/ancestral.bf");
LoadFunctionLibrary("SelectionAnalyses/modules/io_functions.ibf");
LoadFunctionLibrary("SelectionAnalyses/modules/selection_lib.ibf");
LoadFunctionLibrary("libv3/models/codon/BS_REL.bf");
LoadFunctionLibrary("libv3/convenience/math.bf");
LoadFunctionLibrary("libv3/models/binary/charbinary.bf"); 			  			// character model settings 
LoadFunctionLibrary("libv3/models/binary/empirical.bf"); 			  			// character model settings - used to allow setting frequencies as MLEs 
LoadFunctionLibrary("libv3/models/binary.bf");
LoadFunctionLibrary("/modules/custom_functions.bf");


/* ________________________ ENVIRONMENT VARIABLES ________________________ */

utility.SetEnvVariable ("NORMALIZE_SEQUENCE_NAMES", TRUE);	// defined based on RELAX.bf
utility.SetEnvVariable ("ASSUME_REVERSIBLE_MODELS", TRUE);	// defined based on RELAX.bf
utility.SetEnvVariable ("REPLACE_TREE_STRUCTURE", TRUE); 	// assures initialization of the tree every time it is re-loaded - required for loading histories repeatedly, with the same name
utility.SetEnvVariable("ACCEPT_ROOTED_TREES", TRUE);		// allows to preserve rooted trees in the generation of a HyPhy tree instance

/* ________________________ HARDCODED PARAMETERS ________________________ */

/* ___________________ HARDCODED PARAMETERS FOR DEBUGGING _______________ */
mu_interval = 0.1;							// increased the interval for debugging
pi_0_interval = 0.1;						// increased the interval for debugging
sequence_optimization_iterations_num = 0;	// used for counting number of sequence optimization iterations
histories_dir = io.PromptUserForString("\n>Provide existing directory to hold the last character histories generated by the optimization procedure");

// character histories sampling properties
maxSimulationsNum = 100000;

// numeric seetings
almostZero = 1.0e-10;

/* ________________________________ MAIN ________________________________ */

/* display model to the user */
trait_relax.display_model();

/* initiate script parameters */
trait_relax.init();

/* process user input */
trait_relax.process_input();

/* create the sequence model components and perform preliminary fitting for initialization of the model parameters */
trait_relax.set_model_components();

/* optimize the null model */
trait_relax.optimize_null_model();

/* optimize the alternative model */
trait_relax.optimize_alternative_model();

/* perform the test */
trait_relax.perform_test();

/* debug - print the number of sequence model optimization iterations */
fprintf(stdout, "number of sequence model fitting iterations: ", sequence_optimization_iterations_num, "\n"); // debug


/* ___________________ MAIN AUXILIARY FUNCTIONS ___________________ */


/**
 * @name trait_relax.display_model
 * @usage presents model into into the terminal
 */
function trait_relax.display_model() 
{
	
	trait_relax.analysis_description = {
								   terms.io.info : "TraitRELAX (A test of association between a binary phenotypic trait and the selection pattern (intensification or relaxation) that operates on the sequence data",
								   terms.io.version : "1.0",
								   terms.io.char_0 : "TraitRELAX: Detecting association between phenotypic traits and changes in selective pressure (2018)... hopefully?",
								   terms.io.authors : "Keren Halabi, Eli Levi Karin, Sergei L Kosakovsky Pond, Itay Mayrose, Tel Aviv University and Temple iGEM",
								   terms.io.contact : "halabikeren@mail.tau.ac.il",
								   terms.io.requirements : "trait character alignment, codon alignment and a phylogenetic tree"
								  };

	io.DisplayAnalysisBanner ( trait_relax.analysis_description );
	
}

		
/**
 * @name trait_relax.init
 * @usage sets the initial parameters for the pipeline
 */
function trait_relax.init() 
{	
	// initialization of documentation json file
	trait_relax.json = { terms.json.input: {},
						  terms.json.fits : {},
						  terms.json.timers : {},
						  terms.json.test_results : {}
						  };
	
	// declare model parameters for json documentation
	trait_relaxation_parameter = "trait_relax.K";
	trait_dependent_site_proportion = "trait_relax.p";
	trait_relax.rate_classes = 3;
	trait_relax.MG94_name = terms.json.mg94xrev_sep_rates;
	trait_relax.alternative_name = "TraitRELAX alternative";
	trait_relax.null_name = "TraitRELAX null";
	trait_relax.trait_charachter_substitution_rate = "trait_relax.trait_substitution_rate"; // == mu
	trait_relax.null.codon_substitution_rate = "trait_relax.null.substitution_rate";		// == trait_relax.scaler before alternative optimization
	trait_relax.alternative.codon_substitution_rate = "trait_relax.null.substitution_rate"; // == trait_relax.scaler after alternative optimization


	// set the information display order in the json file
	trait_relax.display_orders = {terms.original_name: -1,
							terms.json.nucleotide_gtr: 0,
							trait_relax.MG94_name: 1,
							trait_relax.alternative.name: 2,
							trait_relax.null.name: 3,
							trait_relax.trait_charachter_substitution_rate: 4,
							trait_relax.null.codon_substitution_rate: 5, 
							trait_relax.alternative.codon_substitution_rate : 6,
							trait_relaxation_parameter: 7,
							trait_dependent_site_proportion: 8
						   };	
	
	// set label names
	trait_relax.char_1.model_branches_name = "char_1";
	trait_relax.char_0.model_branches_name = "char_0";
						   
	// start overall time measurement
	selection.io.startTimer (trait_relax.json [terms.json.timers], "Overall", 0);
}


/**
 * @name trait_relax.process_input
 * @usage requests input paths from the user and processes them into hyphy instances
 */
function trait_relax.process_input() 
{
	
	// accept input paths from the user
	trait_relax.trait_data_path = io.PromptUserForString("\n>Provide full path to the trait character alignment");
	trait_relax.tree_path =  io.PromptUserForString("\n>Provide full path to phylogenetic tree in newick format");
	trait_relax.seq_data_path = io.PromptUserForString("\n>Provide full path to codon sequence alignment");
	trait_relax.json_path = io.PromptUserForString("\n>Provide required output file full path");
	
	trait_relax.use_true_history = io.SelectAnOption ({
										{"No", "[Default] optimize the alternative model with no knowledge of the true history"}
										{"Yes", "optimize the alternative model based on the true history"}
									}, "Use the true history when optimizing the alternative model");	
	
	trait_relax.branch_selector_function = "trait_relax.set_base_partition";
	// if the user whishes to use the true history, request for its path
	if (trait_relax.use_true_history == "Yes") {
		trait_relax.true_history_path = io.PromptUserForString("\n>Provide full path to history in form of phylogenetic tree in newick format");
		trait_relax.branch_selector_function = "trait_relax.set_true_history_partition";
	}
	
	namespace trait_relax { 
		// process the tree input files (sequence alignment, tree and trait data)
		LoadFunctionLibrary ("/modules/TraitRELAX_aux.bf"); // used for loading function the below function inside the scope of namespace "trait_relax" (-> all the instances generated within will be inside the namespace)
		load_input ({utility.getGlobalValue("terms.prefix"): "trait_relax", utility.getGlobalValue("terms.settings") : {utility.getGlobalValue("terms.settings.branch_selector") : branch_selector_function}}, json_path, seq_data_path, tree_path, trait_data_path); // this function also validates that the species in the tree are exactly the same as the ones in the alignment
	}
	
	// validate name compatibility in character data and codon data. The validation with the names in the tree is performed earlier (function: load_input)
	orig_seq_names = Rows (trait_relax.name_mapping);
	orig_char_names = Rows (trait_relax.trait_name_mapping);
	len_res = Columns(orig_seq_names) == Columns(orig_char_names);
	io.CheckAssertion("len_res==1","number of species in the trait alignment doesn't match the number of species in the codon alignment");
	for (i = 0; i < Columns (orig_seq_names); i += 1) {
		converted_seq_name = trait_relax.name_mapping[orig_seq_names[i]];
		converted_char_name = trait_relax.trait_name_mapping[orig_seq_names[i]];
		comp_res = converted_seq_name%converted_char_name;
		io.CheckAssertion("comp_res==1","inconsistent species names in the trait alignment and codon alignment");
	}

}

/**
 * @name trait_relax.declare_model_parameters
 * @usage sets the model parameters that extend the BS-REL model describing the test and reference instances: the selection intensity parameter k and the dependent site proportion p
 */
function trait_relax.declare_model_parameters() 
{
	
	// declare character model parameters
	terms.trait_relax.mu = "character transition rate parameter";
	terms.trait_relax.pi_0 = "base frequency of trait state 0";
	mp_data = trait_relax.set_mp_partition(trait_relax.trait_trees["0"], &trait_relax.trait_dataset, trait_relax.char_0.model_branches_name, trait_relax.char_1.model_branches_name);
	mp_score = mp_data["0"];
	tree_size = custom_functions.compute_tree_size(trait_relax.trait_trees["0"]);
	mp_model_map = {"trait_relax.char_1.model" : utility.Filter (mp_data["1"], '_value_', '_value_ == trait_relax.char_1.model_branches_name'),
                    "trait_relax.char_0.model" : utility.Filter (mp_data["1"], '_value_', '_value_ == trait_relax.char_0.model_branches_name')};
	trait_relax.initial_mu = mp_score/tree_size;
	terms.trait_relax.mu_range = {
			terms.lower_bound: mp_score/tree_size,
			terms.upper_bound: 2*mp_score/tree_size
		};
		
	terms.trait_relax.pi_0 = "frequency of charcter state 0";
	HarvestFrequencies(trait_relax.char_empirical_frequencies, ^trait_relax.trait_filter_names["0"], 1, 1, 1);
	trait_relax.initial_pi_0 = trait_relax.char_empirical_frequencies[0][0];
	terms.trait_relax.pi_0_range = {
			terms.lower_bound: 0.01, // do not allow value 0 in order to avoid observing state in the character transition matrix
			terms.upper_bound: 0.99  // do not allow value 1 in order to avoid observing state in the character transition matrix 
		};
	
	// declare the selection intensity parameter k
	terms.trait_relax.k = "relaxation or intensification parameter";
	terms.trait_relax.k_range    = {
			terms.lower_bound: "0",
			terms.upper_bound: "50"
		};
		
	// declare mixture parameter p for probability of each model
	terms.trait_relax.p = "trait dependent site proportion parameter";
	trait_relax.site_propertions_freedom = "Yes"; // initial value that assumes user wishes to run the prop version - will be altered according to the user's input when reacging the alternative model optimization
	terms.trait_relax.p_range    = {
			terms.lower_bound: "0",
			terms.upper_bound: "1"
		};
	
	// reset the disctionary that will hold the latest estimated sequence model parameters to assign to the model that is generated in ech iteration
	trait_relax.latest_estimates = None;
}


/**
 * @name trait_relax.set_model_constraints
 * @usage sets the constrains on the global parameters of the relax model
 */
function trait_relax.set_model_constraints() 
{ // something gets badly messed up in the alternative fitting (the parameter k is gone and p is placed as a local parameter...)

	// set a constraint on trait_relax.p, with required (i.e, the user cohse the no prop version)
	if (trait_relax.site_propertions_freedom == "No") {
		parameters.SetConstraint (trait_dependent_site_proportion, terms.parameters.one, terms.global);
	}

	// restrict the model parameters to be the same for the test and reference
	trait_relax.bound_weights = models.BindGlobalParameters ({"0" : trait_relax.char_0.model, "1" : trait_relax.char_1.model}, terms.mixture.mixture_aux_weight + ".+");
	models.BindGlobalParameters ({"0" : trait_relax.char_1.model, "1" : trait_relax.char_0.model}, terms.nucleotideRate("[ACGT]","[ACGT]"));

	// restrict the first two omegas (expected value is limited to be at most 1 --> use terms.range01)
	for (trait_relax.i = 1; trait_relax.i < trait_relax.rate_classes; trait_relax.i += 1) {
		parameters.SetRange (model.generic.GetGlobalParameter (trait_relax.char_0.model , terms.AddCategory (terms.parameters.omega_ratio,trait_relax.i)), terms.range01);
		parameters.SetRange (model.generic.GetGlobalParameter (trait_relax.char_1.model , terms.AddCategory (terms.parameters.omega_ratio,trait_relax.i)), terms.range01);
		// restrict each omega of the test model to be equal to the corresponding omega in the reference model, raised to the power of the relaxation parameter
		parameters.SetConstraint (model.generic.GetGlobalParameter (trait_relax.char_1.model , terms.AddCategory (terms.parameters.omega_ratio,trait_relax.i)),
								  model.generic.GetGlobalParameter (trait_relax.char_0.model , terms.AddCategory (terms.parameters.omega_ratio,trait_relax.i)) + "^" + trait_relaxation_parameter,
								  terms.global);
	}

	// restrict the last omega (expected value can be larger than 1 --> use terms.range_gte1) 
	parameters.SetRange (model.generic.GetGlobalParameter (trait_relax.char_0.model , terms.AddCategory (terms.parameters.omega_ratio,trait_relax.rate_classes)), terms.range_gte1);
	parameters.SetRange (model.generic.GetGlobalParameter (trait_relax.char_1.model , terms.AddCategory (terms.parameters.omega_ratio,trait_relax.rate_classes)), terms.range_gte1);
	// restrict the last omega of the test model to be equal to the corresponding omega in the reference model, raised to the power of the relaxation parameter
	parameters.SetConstraint (model.generic.GetGlobalParameter (trait_relax.char_1.model , terms.AddCategory (terms.parameters.omega_ratio,trait_relax.i)),
							  model.generic.GetGlobalParameter (trait_relax.char_0.model , terms.AddCategory (terms.parameters.omega_ratio,trait_relax.i)) + "^" + trait_relaxation_parameter,
							  terms.global);
}


/** @name trait_relax.apply_latest_evaluations()
 * @usage apply the last estimated parameters (held in the dictionary names trait_relax.latest_estimates) BEFORE setting the constraints (in order to avoid running over them with the assignment of the latest estimates - see github issue 753)
 */
function trait_relax.apply_latest_evaluations()
{
	if (Type(trait_relax.latest_estimates) == "AssociativeList") { 
		parameters.SetValues(trait_relax.latest_estimates);
	}	
}


/**
 * @name trait_relax.set_character_model
 * @usage generates the codon model instance as a two state Markov model
 */
function trait_relax.set_character_model()
{
	trait_relax.null.mu = trait_relax.initial_mu;
	trait_relax.null.pi_0 = trait_relax.initial_pi_0;
	trait_likelihood_function = trait_relax.generate_character_likelihood_function(trait_relax.null.mu, trait_relax.null.pi_0, "trait_relax.trait", trait_relax.trait_filter_names, trait_relax.trait_trees);
}


/**
 * @name trait_relax.set_codon_model
 * @usage generates the codon model instance as a set of two sub-instances: test and reference, which are extensions of the BS-REL model
 */
function trait_relax.set_codon_model() 
{	
	// define the codon model as an extension of the BS-REL model, where each branch can have one of several (3) w values

	// set the test model as an extension of the BS-REL model
	trait_relax.char_1.model =  model.generic.DefineMixtureModel("models.codon.BS_REL.ModelDescription",
			"trait_relax.char_1.model", {
				"0": parameters.Quote(terms.global),
				"1": trait_relax.codon_data_info[terms.code],
				"2": parameters.Quote (trait_relax.rate_classes) // the number of rate classes
			},
			trait_relax.filter_names,
			None);
		
	// set the reference model as an extension of the BS-REL model
	trait_relax.char_0.model =  model.generic.DefineMixtureModel("models.codon.BS_REL.ModelDescription",
			"trait_relax.char_0.model", {
				"0": parameters.Quote(terms.global),
				"1": trait_relax.codon_data_info[terms.code],
				"2": parameters.Quote (trait_relax.rate_classes) // the number of rate classes
			},
			trait_relax.filter_names,
			None);
	
	// add the relaxation parameter to the test model, and constrain the Q matrix such that the Q matrix of the test model is a function of the Q matrix of the reference model
	parameters.DeclareGlobalWithRanges (trait_relaxation_parameter, 1, terms.trait_relax.k_range[terms.lower_bound], terms.trait_relax.k_range[terms.upper_bound]); 
	model.generic.AddGlobal (trait_relax.char_1.model, trait_relaxation_parameter, terms.trait_relax.k); 

	// add the mixture parameter trait_relax.p
	parameters.DeclareGlobalWithRanges (trait_dependent_site_proportion, 1, terms.trait_relax.p_range[terms.lower_bound], terms.trait_relax.p_range[terms.upper_bound]); 
	model.generic.AddGlobal (trait_relax.char_0.model, trait_dependent_site_proportion, terms.trait_relax.p); 
	model.generic.AddGlobal (trait_relax.char_1.model, trait_dependent_site_proportion, terms.trait_relax.p); 
	
	// apply the last estimated parameters
	trait_relax.apply_latest_evaluations();
	
	// apply the cnostraints on the model parameters AFTER assgining values to the parameters (see Github issue 753)
	trait_relax.set_model_constraints();
							  
	// set a map of the two sub-models of which the RELAX model consists of
	trait_relax.model_object_map = { "trait_relax.char_0.model" : trait_relax.char_0.model,
									 "trait_relax.char_1.model" :       trait_relax.char_1.model };
}


/**
 * @name trait_relax.do_perliminary_fitting
 * @usage perform preliminary fitting of MG-REV to the codon alignment to receive better initial values for the codon model parameters (should reduce running time)
 * The initial values for the sequence model parameters of TraitRELAX are obtained through optimization of simpler models to the data. 
 * This procedure contains two optimization steps. 
 * First, we fit a simple GTR model to nucleotide data. The obtained parameters will be used as initial parameters to MG-REV model. 
 * Second, we fit the MG-REV model. This fitting is divided into two steps. 
 * Third, 
 */
function trait_relax.do_perliminary_fitting() 
{ 
	// duration measurement checkpoint
	selection.io.startTimer (trait_relax.json [terms.json.timers], "Preliminary sequence model fitting", 1);
	
	// get the initial GTR model parameters by optimizing based on the original tree
	namespace trait_relax {
		doGTR_FixedBLs ("trait_relax");
	}
	// set the global MLEs of the GTR model according to the initial GTR parameters of the RELAX model (should reduce optimization duration)
	estimators.fixSubsetOfEstimates(trait_relax.gtr_results, trait_relax.gtr_results[terms.global]); 

	// get the initial MG-REV model parameters by optimizing based on the original tree
	namespace trait_relax {
		scaler_prefix = "trait_relax.scaler";
		doPartitionedMG_FixedBLs ("trait_relax", FALSE);
	}
	io.ReportProgressMessageMD ("TraitRELAX", "codon-refit", "Improving branch lengths, nucleotide substitution biases, and global dN/dS ratios under a full codon model");
	
	trait_relax.final_partitioned_mg_results = custom_functions.FitMGREV_FixedBLs (trait_relax.filter_names, trait_relax.trees, trait_relax.codon_data_info [terms.code], {
		terms.run_options.model_type: terms.local,
		terms.run_options.partitioned_omega: trait_relax.selected_branches,
	}, trait_relax.partitioned_mg_results);

	io.ReportProgressMessageMD("TraitRELAX", "codon-refit", "* " + selection.io.report_fit (trait_relax.final_partitioned_mg_results, 0, trait_relax.codon_data_info[terms.data.sample_size]));

	// extract a global omega value from the local syn-rate and nonsyn-rate estimated for each branch
	trait_relax.global_dnds = selection.io.extract_global_MLE_re (trait_relax.final_partitioned_mg_results, "^" + terms.parameters.omega_ratio);
	trait_relax.report_dnds = {};

	// document the initial values in the json
	utility.ForEach (trait_relax.global_dnds, "_value_", '
		io.ReportProgressMessageMD ("TraitRELAX", "codon-refit", "* " + _value_[terms.description] + " = " + Format (_value_[terms.fit.MLE],8,4));
		trait_relax.report_dnds [(regexp.FindSubexpressions (_value_[terms.description], "^" + terms.parameters.omega_ratio + ".+\\*(.+)\\*$"))[1]] = {"0" : {terms.json.omega_ratio : _value_[terms.fit.MLE], terms.json.proportion : 1}};
	');


	// store initial MG model parameters in the json file
	selection.io.json_store_lf_GTR_MG94 (trait_relax.json,
								trait_relax.MG94_name,
								trait_relax.final_partitioned_mg_results[terms.fit.log_likelihood],
								trait_relax.final_partitioned_mg_results[terms.parameters],
								trait_relax.sample_size,
								utility.ArrayToDict (utility.Map (trait_relax.global_dnds, "_value_", "{'key': _value_[terms.description], 'value' : Eval({{_value_ [terms.fit.MLE],1}})}")),
								(trait_relax.final_partitioned_mg_results[terms.efv_estimate])["VALUEINDEXORDER"][0],
								trait_relax.display_orders[trait_relax.MG94_name]);

	// store synonymous rate and non-synonymous rate for each branch (as these parameters are unique per branch)
	utility.ForEachPair (trait_relax.filter_specification, "_key_", "_value_",
		'selection.io.json_store_branch_attribute(trait_relax.json,trait_relax.MG94_name, terms.branch_length, trait_relax.display_orders[trait_relax.MG94_name],
												 _key_,
												 selection.io.extract_branch_info((trait_relax.final_partitioned_mg_results[terms.branch_length])[_key_], "selection.io.branch.length"));');
												 
	// set the omega parameters from the MG-REV model optimization to be the ones of the RELAX reference and test models
	trait_relax.ge_guess = relax.DistributionGuess(utility.Map (selection.io.extract_global_MLE_re (trait_relax.final_partitioned_mg_results, "^" + terms.parameters.omega_ratio + ".+test.+"), "_value_", "_value_[terms.fit.MLE]"));
	trait_relax.distribution = models.codon.BS_REL.ExtractMixtureDistribution(trait_relax.char_0.model);
	// assumption: this extracts 3 initial omegas from the single global dN/dS ratio evaluated when optimizing the MG-REV model
	parameters.SetStickBreakingDistribution (trait_relax.distribution, trait_relax.ge_guess); 
	
	trait_relax.latest_estimates = trait_relax.final_partitioned_mg_results[utility.getGlobalValue("terms.global")];
	 
	selection.io.stopTimer (trait_relax.json [terms.json.timers], "Preliminary sequence model fitting");
}


/**
 * @name trait_relax.set_model_components
 * @usage creates the model instance and initialize its parameters to the values of some preliminary fitting in order to reduce optimization running time in practice
 * @The traitRELAX model includes the following components: 
 * 1. parameters of the character model: mu and pi_0
 * 2. parameters of the sequence model. The sequence model consists of two components (test and reference). Each of these has the following parameters, whose values are identical in the two components: 
 * 2a. GTR parameters (5 transition parameters and 3 frequency parameters)
 * 2b. the ka/ks ratio parameters: 5 parameters in total. There are 3 omega's and 2 proportions parameters
 * 2c. The selection intensity parameter: k - this parameter is free to vary only in the test component. In the reference component it is fixed to one. 
 */
function trait_relax.set_model_components() 
{
	// declare the model parameters that are additional to the standard BS-REL model
	trait_relax.declare_model_parameters();
	
	// set the character model as a two state Markov model
	trait_relax.set_character_model();
	
	// set the codon model as two instances that are extensions of the BS-REL model: test and reference 
	trait_relax.set_codon_model();
	
	// do preliminary fitting on the null model parameters
	trait_relax.do_perliminary_fitting();
}


/**
 * @name trait_relax.document_null_fit
 * @usage documents the null fitting result in the json output file
 */
function trait_relax.document_null_fit() 
{
	trait_relax.distribution_for_json = {trait_relax.char_1.model_branches_name : utility.Map (utility.Range (trait_relax.rate_classes, 0, 1),
														 "_index_",
														 "{terms.json.omega_ratio : trait_relax.inferred_distribution [_index_][0],
														   terms.json.proportion  : trait_relax.inferred_distribution [_index_][1]}")};

	trait_relax.distribution_for_json   [trait_relax.char_0.model_branches_name] =   trait_relax.distribution_for_json   [trait_relax.char_1.model_branches_name];

	selection.io.json_store_lf (trait_relax.json,
								trait_relax.null_name ,
								trait_relax.null_model.fit.log_likelihood, // document the log likelihood of the full model, character + sequence
								trait_relax.null_model.fit[terms.parameters] + 9+2 , // +9 comes from CF3x4, +2 comes from the character model
								trait_relax.codon_data_info[terms.data.sample_size],
								trait_relax.distribution_for_json,
								trait_relax.display_orders[trait_relax.null_name]
							);
							
	// document character model parameters
	((trait_relax.json [terms.json.fits])[trait_relax.null_name])[terms.trait_relax.mu] = trait_relax.null.mu;
	((trait_relax.json [terms.json.fits])[trait_relax.null_name])[terms.trait_relax.pi_0] = trait_relax.null.pi_0;

	selection.io.json_store_branch_attribute(trait_relax.json, trait_relax.null_name, terms.branch_length, trait_relax.display_orders[trait_relax.null_name],
												 0,
												 selection.io.extract_branch_info((trait_relax.null_model.fit[terms.branch_length])[0], "selection.io.branch.length"));	
}


/**
 * @name trait_relax.optimize_null_model
 * @usage requests input paths from the user and processes them into hyphy instances
 */
function trait_relax.optimize_null_model() 
{
	selection.io.startTimer (trait_relax.json [terms.json.timers], "TraitRELAX null model fitting", 2);

	// optimize the joint model using a two step procedure until convergence 
	
	// optimize the character model parameters
	Optimize(trait_relax.null.trait_mles, trait_likelihood_function);
	trait_relax.null.mu = trait_relax.trait.model.mu_01; // for improvement: issue in trait_relax.null.trait_mles: the MLE of mu is absent from the array. It can be accesed directory for now (it is called trait_relax.trait.model.mu_01). Refers to Github issue 731
	trait_relax.null.pi_0 = trait_relax.null.trait_mles[0][0];
	
	// compute the log likelihood of the character model given the best parameters
	trait_relax.null_model.fit.character_log_likelihood = trait_relax.null.trait_mles[1][0];
	  
	// generate a partition of the tree branches in which all the branches are classified to the reference category
	base_model_map = {"trait_relax.char_1.model" : utility.Filter (trait_relax.selected_branches[0], '_value_', '_value_ == trait_relax.char_1.model_branches_name'),
                    "trait_relax.char_0.model" : utility.Filter (trait_relax.selected_branches[0], '_value_', '_value_ == trait_relax.char_0.model_branches_name')};

	// optimize the null model while preserving the relations between branch lengths
	io.ReportProgressMessageMD ("TraitRELAX", "null", "Fitting the null (K := 1) model");

	// constraint k to be 1
	parameters.SetConstraint (model.generic.GetGlobalParameter (trait_relax.char_1.model , terms.trait_relax.k), terms.parameters.one, terms.global);
	
	// optimize the sequence model parameters (i.e, fit the RELAX null model to the data)
	trait_relax.null_model.fit = custom_functions.FitLF_FixedBLs (trait_relax.filter_names, trait_relax.trees, None, { "0" : base_model_map}, 
																		trait_relax.final_partitioned_mg_results, trait_relax.model_object_map, 
																		{terms.run_options.proportional_branch_length_scaler: trait_relax.scaler, "optimize_branch_lengths": FALSE});
	
	// update the latest estimates to be the resluts of the null model fitting
	trait_relax.latest_estimates = trait_relax.null_model.fit[utility.getGlobalValue("terms.global")];
	
	// extract the log likelihood of the sequence model (RELAX) given the best parameters
	trait_relax.null_model.fit.sequence_log_likelihood = trait_relax.null_model.fit[utility.getGlobalValue("terms.fit.log_likelihood")];
	
	fprintf(stdout, "* Sequence Log Likelihood = ", trait_relax.null_model.fit.sequence_log_likelihood, "\n"); // debug
	
	// sum the log likelihood of the character model and log likelihood of the sequence model to achieve the log likelihood of the TraitRELAX null model
	trait_relax.null_model.fit.log_likelihood = trait_relax.null_model.fit.character_log_likelihood + trait_relax.null_model.fit.sequence_log_likelihood;
	
	// update the total likelihood in the fitting dictionary for reporting needs
	trait_relax.null_model.fit[utility.getGlobalValue("terms.fit.log_likelihood")] = trait_relax.null_model.fit.log_likelihood;
	
	// report null fitting results
	io.ReportProgressMessageMD ("TraitRELAX", "null", "* " + selection.io.report_fit (trait_relax.null_model.fit, 9+2, trait_relax.codon_data_info[terms.data.sample_size])); // added 9 frequencies parameters + 2 character model parameters as xp argument

	io.ReportProgressMessageMD("TraitRELAX", "null", "* The following rate distribution for char_1/char_0 branches was inferred");
	trait_relax.inferred_distribution = parameters.GetStickBreakingDistribution (models.codon.BS_REL.ExtractMixtureDistributionFromFit (trait_relax.char_1.model, trait_relax.null_model.fit)) % 0;
	selection.io.report_dnds (trait_relax.inferred_distribution);
	
	// document fitting results in the json file
	trait_relax.document_null_fit();
	
	// no need to clear the constraint on k (for the purpose of the alternative model fitting), as it was automatically removed upon the deletion of the likelihood function
	// parameters.RemoveConstraint(model.generic.GetGlobalParameter (trait_relax.char_1.model , terms.trait_relax.k));
	
	selection.io.stopTimer (trait_relax.json [terms.json.timers], "TraitRELAX null model fitting");
}


/**
* @name trait_relax.set_starting_point
* @usage sets the initial values of the sequence model parameters in the alternative model optimization
*/
function trait_relax.set_starting_point() 
{	
	fprintf(stdout, "### Setting starting point for TraitRELAX alternative model fitting\n\n");
	
	// if user chose to set the starting point according to the RELAX alternative MLEs -> perform RELAX alternative fitting to the data based on the maximum parsimony partition of the tree branches
	if (trait_relax.alternative_starting_point == "RELAX alternative") {
		
		// set initial values  to be unbiased by the null model fitting
		/* without this line:						    K is inferred as 1 in the dummy test case
		   with this line + fixing branch lengths:	    K is inferred as 49 in the dummy test case
		   with this line + optimizing branch lengths:  K is inferred as 1.28 in the dummy test case - same as in RELAX with the mp partition */
		//trait_relax.latest_estimates = trait_relax.final_partitioned_mg_results[utility.getGlobalValue("terms.global")];
		
		// set the codon model
		trait_relax.set_codon_model();
		
		// fit the RELAX alternative model to the data, based on the maximum parsimonious partition of the tree branches
		trait_relax.alternative_model.initial_fit = custom_functions.FitLF_FixedBLs (trait_relax.filter_names, trait_relax.trees, None, { "0" : mp_model_map}, 
																		trait_relax.final_partitioned_mg_results, trait_relax.model_object_map, 
																		{terms.run_options.proportional_branch_length_scaler: trait_relax.scaler, "optimize_branch_lengths": FALSE});
	
		trait_relax.latest_estimates = trait_relax.alternative_model.initial_fit[utility.getGlobalValue("terms.global")];
		fprintf(stdout, "### Used the RELAX alternative model as a starting point\n");
		fprintf(stdout, "* Achieved Sequence Log Likelihood = ", trait_relax.alternative_model.initial_fit[utility.getGlobalValue("terms.fit.log_likelihood")], "\n"); 
		fprintf(stdout, "* Starting Point Of K = ", ((trait_relax.alternative_model.initial_fit[utility.getGlobalValue("terms.global")])["relaxation or intensification parameter"])[utility.getGlobalValue("terms.fit.MLE")], "\n\n");
		
	// if the user chose to set the starting point according to the RELAX null model -> set the starting point to hold the MLEs achieved for the sequence model in the trait relax null model fitting 
	} else {
		trait_relax.latest_estimates = trait_relax.null_model.fit[utility.getGlobalValue("terms.global")];
	}
}


/**
 * @name trait_relax.optimize_by_true_history
 * @usage performs a grid optimization of the alternative model with a single layer, that optimizes the sequence model given the true history. the character model are set by grid optimzation which is independent of the history (like in the null 	model fitting)
 */
function trait_relax.optimize_by_true_history() {
	trait_relax.alternative.mu = trait_relax.null.mu;
	trait_relax.alternative.pie_0 = trait_relax.null.pi_0;
	
	// compute the log likelihood of the character model given the best parameters
	trait_relax.null_model.fit.character_log_likelihood = trait_relax.null.trait_mles[1][0];
	
	io.ReportProgressMessageMD ("TraitRELAX", "alt", "optimal character model parameters fixed");
	fprintf(stdout, "* mu = ", trait_relax.alternative.mu, "\n"); 
	fprintf(stdout, "* pie_0 = ", trait_relax.alternative.pie_0, "\n\n"); 
	
	joint_sequence_filter_names = {}; 
	joint_sequence_trees = {}; 

	// prepare inout for the joint likelihood function
	lf_formula = "'Log((1-trait_relax.p)*SITE_LIKELIHOOD[0]+trait_relax.p*((SITE_LIKELIHOOD[1])))'";
	custom_functions.dup_data_filter("data_filter_0", &trait_relax.codon_data);
	joint_sequence_filter_names[0] = "data_filter_0";
	joint_sequence_trees[0] = trait_relax.trees[0];
	model_maps = {};
	model_maps[0] = trait_relax.map_all_to_reference();

	// convert the "FG" labeling into "char_1" labeling and "BG" to "char_0" labeling
	custom_functions.dup_data_filter("data_filter_1", &trait_relax.codon_data);
	joint_sequence_filter_names[1] = "data_filter_1";
	joint_sequence_trees[1] = trait_relax.trees[0];
	model_maps[1] = base_model_map;
	
	trait_relax.set_codon_model();
	
	trait_relax.alternative_model.fit = custom_functions.FitLF_FixedBLs(joint_sequence_filter_names, joint_sequence_trees, lf_formula, model_maps, trait_relax.alternative_model.initial_parameters, trait_relax.model_object_map, {terms.run_options.proportional_branch_length_scaler: trait_relax.scaler, "custom_lf_formula": TRUE, "optimize_branch_lengths": FALSE});
	
	io.ReportProgressMessageMD ("TraitRELAX", "alt", "RELAX parameters optimized");
	
	// update the character model parameters
	trait_relax.alternative.mu = trait_relax.null.mu;
	trait_relax.alternative.pi_0 = trait_relax.null.pi_0;
	
	// extract the sequence likelihood and by site likelihood																
	sitewise_blockwise_likelihoods = trait_relax.alternative_model.fit ["sitewise_likelihoods"];
	
	// compute the log likelihood of the character model given the best parameters
	trait_relax.alternative_model.fit.character_log_likelihood = trait_relax.null_model.fit.character_log_likelihood;
	
	// extract the log likelihood of the sequence model given the best parameters
	trait_relax.alternative_model.fit.sequence_log_likelihood = trait_relax.alternative_model.fit [utility.getGlobalValue("terms.fit.log_likelihood")];
	
	// sum the log likelihood of the character model and the log likelihood of the sequence model to achieve the log likelihood of the TraitRELAX alternative model
	trait_relax.alternative_model.fit.log_likelihood = trait_relax.alternative_model.fit.character_log_likelihood + trait_relax.alternative_model.fit.sequence_log_likelihood;
	
	// update the total likelihood in the fitting dictionary for reporting needs
	trait_relax.alternative_model.fit [utility.getGlobalValue("terms.fit.log_likelihood")] = trait_relax.alternative_model.fit.log_likelihood;
}


/**
 * @name trait_relax.set_character_grid
 * @param {Dict} character_data_filter  		- dictionary holding a pointer to the character data
 * @param {Dict} tree							- dictionary holding the tree provided by the user
 * @return {Dict} character_grid	       		- dictionary holding the generated character grid in two dimensions: "mu" and "pi_0"
 * @usage sets the character grid as a matrix of mu and pi0 combinations for the character model
 */
lfunction trait_relax.set_character_grid(character_data_filter, tree, mu_interval, pi_0_interval, mu_range, pi_0_range) 
{	
	character_grid = {};
	character_grid["mu"] = {};
	character_grid["pi_0"] = {};
	
	mu_counter = 0;
	for (mu=mu_range[utility.getGlobalValue("terms.lower_bound")]; mu <=mu_range[utility.getGlobalValue("terms.upper_bound")]; mu += mu_interval) {
		(character_grid["mu"])[mu_counter] = mu;
		mu_counter += 1;
	}
	pi_0_counter = 0;
	for (pi_0=pi_0_range[utility.getGlobalValue("terms.lower_bound")]; pi_0 <=pi_0_range[utility.getGlobalValue("terms.upper_bound")]; pi_0 += pi_0_interval) {
		(character_grid["pi_0"])[pi_0_counter] = pi_0;
		pi_0_counter += 1;
	}
	
	return character_grid	
}


/**
 * @name trait_relax.optimize_by_grid
 * @usage performs a grid optimization of the alternative model with two layers: the first one fixes the sequence model and optimizes the character model, and the second fixes the character model and optimizes the sequence model
 */
function trait_relax.optimize_by_grid() 
{	
	// set the character gird
	character_grid = trait_relax.set_character_grid(&trait_relax.trait_dataset, trait_relax.trees["0"], mu_interval, pi_0_interval, terms.trait_relax.mu_range, terms.trait_relax.pi_0_range);

	// set the initial values of the alternative model to be the same as the optimized values of the null model
	// trait_relax.alternative_model.initial_parameters will hold the initial parameters of the alternative sequence model, until convergence
	prev_log_likelihood = -1e500;
	curr_log_likelihood = -1e5;

	// optimize the joint model using a two step procedure until convergence
	while  (curr_log_likelihood > prev_log_likelihood + min_log_likelihood_diff) {

		// update the log likelihood to be the best achieved to far
		prev_log_likelihood = curr_log_likelihood;
		
		/* step 1: optimize the character model parameters while fixing the sequence model parameters using grid optimization */
		best_char_fit = {};
		best_char_fit["mu"] = -1;
		best_char_fit["pi_0"] = -1;
		best_log_likelihood = -1e500;

		io.ReportProgressMessageMD ("TraitRELAX", "alt", "\n### Searching the grid for the optimized character model parameters");
		
		// iterate over all the possible character grid parameters
		for (m=0; m<Abs(character_grid["mu"]); m+=1) {
			for (p=0; p<Abs(character_grid["pi_0"]); p+=1) {

				// compute the log likelihood value of the joint likelihood function given the corresponding character grid parameters 
				results = trait_relax.get_joint_likelihood((character_grid["mu"])[m], (character_grid["pi_0"])[p], &trait_likelihood_function, trait_relax.trait_filter_names, &trait_relax.codon_data, trait_relax.trees, num_of_histories, trait_relax.approximation_method,
				trait_relax.model_object_map, &trait_relax.alternative_model.initial_parameters, FALSE, maxSimulationsNum, {"return_extended_form": TRUE}, &base_model_map);
				log_likelihood = (^ results) [utility.getGlobalValue("terms.fit.log_likelihood")];
				if (log_likelihood > best_log_likelihood ) {
					best_log_likelihood = log_likelihood; // update the best achieved log likelihood
					best_char_fit["mu"] = (character_grid["mu"])[m];
					best_char_fit["pi_0"] = (character_grid["pi_0"])[p];
				}
				
			}
		}

		io.ReportProgressMessageMD ("TraitRELAX", "alt", "optimal character model parameters fixed");
		fprintf(stdout, "* mu = ", best_char_fit["mu"], "\n"); 
		fprintf(stdout, "* pi_0 = ", best_char_fit["pi_0"], "\n");
		fprintf(stdout, "* Log likelihood = ", log_likelihood, "\n\n");
		prev_log_likelihood = log_likelihood;
		
		/* step 2: optimize the sequence model (RELAX) parameters while fixing the character model parameters using conjugate gradient method */
		io.ReportProgressMessageMD ("TraitRELAX", "alt", "### optimizing RELAX parameters");
		
		// update the character model parameters
		trait_relax.alternative.mu = best_char_fit["mu"];
		trait_relax.alternative.pi_0 = best_char_fit["pi_0"];

		// optimize the sequence model given the best character parameters
		results = trait_relax.get_joint_likelihood(best_char_fit["mu"], best_char_fit["pi_0"], &trait_likelihood_function, trait_relax.trait_filter_names, &trait_relax.codon_data, trait_relax.trees, num_of_histories, trait_relax.approximation_method, trait_relax.model_object_map, &trait_relax.alternative_model.initial_parameters, TRUE, maxSimulationsNum, {"write_histories": TRUE, "histories_dir": histories_dir, "return_extended_form": TRUE}, &base_model_map);
		curr_log_likelihood = (^ results) [utility.getGlobalValue("terms.fit.log_likelihood")];
		sitewise_blockwise_likelihoods = (^ results) ["sitewise_likelihoods"];
		
		// update the latest estimates of the sequence model
		trait_relax.latest_estimates = (^ results) [utility.getGlobalValue("terms.global")];

		io.ReportProgressMessageMD ("TraitRELAX", "alt", "RELAX parameters optimized");
		fprintf(stdout, "* Log likelihood = ", curr_log_likelihood, "\n");
		fprintf(stdout, "* Delta = ", curr_log_likelihood - prev_log_likelihood, "\n\n");
		sequence_optimization_iterations_num += 1;
	}
	
	// set the optimized alternative model parameters to the ones that triggered the convergence
	trait_relax.alternative_model.fit = (^ results);
	
	// compute the log likelihood of the character model given the best parameters
	trait_relax.alternative_model.fit.character_log_likelihood = best_log_likelihood;
	
	// extract the log likelihood of the sequence model given the best parameters
	trait_relax.alternative_model.fit.sequence_log_likelihood = trait_relax.alternative_model.fit[utility.getGlobalValue("terms.fit.log_likelihood")];
	
	// sum the log likelihood of the character model and the log likelihood of the sequence model to achieve the log likelihood of the TraitRELAX alternative model
	trait_relax.alternative_model.fit.log_likelihood = trait_relax.alternative_model.fit.character_log_likelihood + trait_relax.alternative_model.fit.sequence_log_likelihood;
	
	//update the log likelihood value of the model tobe the character-sequence joint log likelihood
	trait_relax.alternative_model.fit[utility.getGlobalValue("terms.fit.log_likelihood")] = trait_relax.alternative_model.fit.log_likelihood;
}


/**
 * @name trait_relax.optimize_by_brent
 * @usage performs a grid optimization of the alternative model with two layers: the first one fixes the sequence model and optimizes the character model, and the second fixes the character model and optimizes the sequence model
 */
function trait_relax.optimize_by_brent() 
{
	// set the initial values of the alternative model to be the same as the optimized values of the null model
	// trait_relax.alternative_model.initial_parameters will hold the initial parameters of the alternative sequence model, until convergence
	prev_log_likelihood = -1e500;
	curr_log_likelihood = -1e5;

	// optimize the joint model using a two step procedure until convergence
	while  (curr_log_likelihood > prev_log_likelihood + min_log_likelihood_diff) {
		
		// update the log likelihood to be the best achieved to far
		prev_log_likelihood = curr_log_likelihood;
		
		/* step 1: optimize the character model parameters while fixing the sequence model parameters using grid optimization */
		io.ReportProgressMessageMD ("TraitRELAX", "alt", "\n#### Searching the for the optimal character model parameters");
			
		// optimize the character model parameters with regards to the joint likelihood function
		intial_mu = trait_relax.null.mu; // KEREN 10.01.18: for some reason, mu is absent from the MLEs array. Send question to Sptehanie
		initial_pi_0 = trait_relax.null.pi_0;
		
		// fix mu to the MLE of the null model and optimize the joint likelihood function with regards to pi_0 (for starting with mu, set pi_0 to initial_pi_0)
		func_args = {0: intial_mu, 1: initial_pi_0, 2: &trait_likelihood_function, 3: trait_relax.trait_filter_names, 4: &trait_relax.codon_data, 5: trait_relax.trees, 6: num_of_histories, 7: trait_relax.approximation_method, 8: trait_relax.model_object_map, 9: &trait_relax.alternative_model.initial_parameters, 10: FALSE, 11: maxSimulationsNum, 12: None, 13: &base_model_map}; 
		optimal_pi_0 = initial_pi_0;
		log_likelihood = custom_functions.brent_optimize(terms.trait_relax.pi_0_range[terms.lower_bound], initial_pi_0, terms.trait_relax.pi_0_range[terms.upper_bound], "trait_relax.wrapper_get_joint_likelihood", 1, &func_args, min_dist, &optimal_pi_0);
		
		// fix pi_0 to the brent optimized one, and optimize the joint likelihood function with regards to pi_0 
		func_args = {0: intial_mu, 1: optimal_pi_0, 2: &trait_likelihood_function, 3: trait_relax.trait_filter_names, 4: &trait_relax.codon_data, 5: trait_relax.trees, 6: num_of_histories, 7: trait_relax.approximation_method, 8: trait_relax.model_object_map, 9: &trait_relax.alternative_model.initial_parameters, 10: FALSE, 11: maxSimulationsNum, 12: None, 13: &base_model_map}; 
		optimal_mu = initial_mu;
		log_likelihood = custom_functions.brent_optimize(terms.trait_relax.mu_range[terms.lower_bound], intial_mu, terms.trait_relax.mu_range[terms.upper_bound], "trait_relax.wrapper_get_joint_likelihood", 0, &func_args, 0.01, &optimal_mu);
		
		io.ReportProgressMessageMD ("TraitRELAX", "alt", "optimal character model parameters fixed");
		fprintf(stdout, "* mu = ", optimal_mu, "\n"); 
		fprintf(stdout, "* pi_0 = ", optimal_pi_0, "\n"); 
		fprintf(stdout, "* Log likelihood = ", log_likelihood, "\n\n");
		prev_log_likelihood = log_likelihood;
		
		/* step 2: optimize the sequence model (RELAX) parameters while fixing the character model parameters using conjugate gradient method */
		io.ReportProgressMessageMD ("TraitRELAX", "alt", "### optimizing RELAX parameters");

		// optimize the sequence model given the best character parameters
		results = trait_relax.get_joint_likelihood(optimal_mu, optimal_pi_0, &trait_likelihood_function, trait_relax.trait_filter_names, &trait_relax.codon_data, trait_relax.trees, num_of_histories, trait_relax.approximation_method, trait_relax.model_object_map, &trait_relax.alternative_model.initial_parameters, TRUE, maxSimulationsNum, {"write_histories": TRUE, "histories_dir": histories_dir, "return_extended_form": TRUE}, &base_model_map,);

		curr_log_likelihood = (^ results) [utility.getGlobalValue("terms.fit.log_likelihood")];
		sitewise_blockwise_likelihoods = (^ results) ["sitewise_likelihoods"];
		
		// update the latest estimates of the sequence model
		trait_relax.latest_estimates = (^ results) [utility.getGlobalValue("terms.global")];

		io.ReportProgressMessageMD ("TraitRELAX", "alt", "RELAX parameters optimized");
		fprintf(stdout, "* Log likelihood = ", curr_log_likelihood , "\n");
		fprintf(stdout, "* Delta = ", curr_log_likelihood - prev_log_likelihood, "\n\n");
		sequence_optimization_iterations_num += 1;
	}
	
	// update the character model parameters
	trait_relax.alternative.mu = optimal_mu;
	trait_relax.alternative.pi_0 = optimal_pi_0;
	
	// set the optimized alternative model parameters to the ones that triggered the convergence
	trait_relax.alternative_model.fit = (^ results);
	
	// compute the log likelihood of the character model given the best parameters
	trait_relax.alternative_model.fit.character_log_likelihood = best_log_likelihood;
	
	// extract the log likelihood of the sequence model given the best parameters
	trait_relax.alternative_model.fit.sequence_log_likelihood = trait_relax.alternative_model.fit[utility.getGlobalValue("terms.fit.log_likelihood")];
	
	// sum the log likelihood of the character model and the log likelihood of the sequence model to achieve the log likelihood of the TraitRELAX alternative model
	trait_relax.alternative_model.fit.log_likelihood = trait_relax.alternative_model.fit.character_log_likelihood + trait_relax.alternative_model.fit.sequence_log_likelihood;
	
	//update the log likelihood value of the model tobe the character-sequence joint log likelihood
	trait_relax.alternative_model.fit[utility.getGlobalValue("terms.fit.log_likelihood")] = trait_relax.alternative_model.fit.log_likelihood;
}


/**
 * @name trait_relax.document_alternative_fit 
 * @usage documents the null fitting result in the json output file
 */
// WIERED INDENTATION - MAYBE A NOTEPAD++ ISSUE
function trait_relax.document_alternative_fit() 
{	
	// TO DO: check if trait_relax.p is now documented after it was associated to both model instances as per SKP's suggestion
	selection.io.json_store_lf (trait_relax.json,
								trait_relax.alternative_name,
								trait_relax.alternative_model.fit[terms.fit.log_likelihood],
								trait_relax.alternative_model.fit[terms.parameters] + added_params_num , // see computation of added_params_num in trait_relax.optimize_alternative_model()
								trait_relax.codon_data_info[terms.data.sample_size],
								trait_relax.distribution_for_json,
								trait_relax.display_orders[trait_relax.alternative_name]
							);

	selection.io.json_store_branch_attribute(trait_relax.json, trait_relax.alternative_name, terms.branch_length, trait_relax.display_orders[trait_relax.alternative_name],
												 0,
												 selection.io.extract_branch_info((trait_relax.alternative_model.fit[terms.branch_length])[0], "selection.io.branch.length"));

	// document character model parameters
	((trait_relax.json [terms.json.fits])[trait_relax.alternative_name])[terms.trait_relax.mu] = trait_relax.alternative.mu;
	((trait_relax.json [terms.json.fits])[trait_relax.alternative_name])[terms.trait_relax.pi_0] = trait_relax.alternative.pi_0;

	selection.io.stopTimer (trait_relax.json [terms.json.timers], "TraitRELAX alternative model fitting");	
	
	trait_relax.distribution_for_json = {trait_relax.char_1.model_branches_name : utility.Map (utility.Range (trait_relax.rate_classes, 0, 1),
												 "_index_",
												 "{terms.json.omega_ratio : trait_relax.inferred_distribution [_index_][0],
												   terms.json.proportion  : trait_relax.inferred_distribution [_index_][1]}"),

							trait_relax.char_0.model_branches_name : utility.Map (utility.Range (trait_relax.rate_classes, 0, 1),
												 "_index_",
												 "{terms.json.omega_ratio : trait_relax.inferred_distribution_ref [_index_][0],
												   terms.json.proportion  : trait_relax.inferred_distribution_ref [_index_][1]}")
						   };	
}


/**
 * @name trait_relax.optimize_alternative_model
 * @usage requests input paths from the user and processes them into hyphy instances
 */
function trait_relax.optimize_alternative_model() 
{	
	// report to the user on alternative model fitting start time
	io.ReportProgressMessageMD ("TraitRELAX", "alt", "Fitting the alternative model to test K != 1");
	selection.io.startTimer (trait_relax.json [terms.json.timers], "TraitRELAX alternative model fitting", 3);	
	
	// set trait_relax.p to be constrained to 1 or not according to the user's choice (first option is TraitPropRELAX - p<=1 and the second option in TraitRELAX - p=1)
	trait_relax.site_propertions_freedom = io.SelectAnOption ({
											{"Yes", "[Default] Allow trait dependent site proportion to be lower than 1"}
											{"No", "Fix trait dependent sites proportion to 1"}
										}, " Allow trait dependent site proportion to be lower than 1 or not");
	
	if (trait_relax.use_true_history == "Yes") {
		trait_relax.optimize_by_true_history();
	} else {
		
		// select the number of character histories to generate per grid iteration
		num_of_histories = io.PromptUser("\n>Select the number of character histories to sample in the alternative model optimization", 3, 1, 10000, FALSE);	// get the required number of sampled character histories

		// request user to choose a starting point for the trait_relax alternative model optimization (either the results of relax null achieved earlier or the results of of relax alternative fitting to a partition based on the character maximum parsimony
		trait_relax.alternative_starting_point = io.SelectAnOption ({
												{"RELAX null", "[Default] initialize the sequence model parameters of the TraitRELAX alternative model to be the MLEs of the RELAX null model"}
												{"RELAX alternative", "initialize the sequence model parameters of the TraitRELAX alternative model to be the MLEs of the RELAX alternative model"}
											}, " Alternative model optimization starting point");	
		
		//request the user to provide chosen approximation method
		trait_relax.approximation_method = io.SelectAnOption ({
												{"Multiple Histories", "[Default] Fit the alternative model to multiple trees representing multiple character histories"}
												{"Expected History", "Fit the alternative model to a single expected history by averaging over multiple histories"}
											}, " TraitRELAX approximation method");
		
		// select convergence cutoff
		min_log_likelihood_diff = io.PromptUser("\n>Select the alternative model optimization convergence cutoff", 0.01, 0.000001, 0.1, FALSE);		 		// optimization minimum difference between previous LL value and current one (condition for convergence)
		
		// set the laternative optimization method (either brent or grid
		trait_relax.optimization_method = io.SelectAnOption ({
											{"grid", "[Default] optimize the alternative model by iteratively choosing character model parameters from a grid"}
											{"brent", "optimize the alternative model by sequentially using brent with regards to one character model parameter"}
										}, " Select optimization method");
	
		// set the starting point of the sequence model in the alternative model
		trait_relax.set_starting_point();
		
		// generate a basic model map that maps all branches into the refrence category, for the independent case tree

		if (trait_relax.optimization_method % "brent") { // optimize the alternative model using the brent approach
			trait_relax.optimize_by_brent();
		} else {
			trait_relax.optimize_by_grid();
		}
	}
										

	
	// report the fitting results
	added_params_num = 9 + 2;  // +9 comes from CF3x4, +2 comes from the character model
	if (trait_relax.site_propertions_freedom == "Yes") {
		added_params_num += 1; // add an additional paameter of the trait depedent sites proportion 
	}
	
	io.ReportProgressMessageMD("TraitRELAX", "alt", "* " + selection.io.report_fit (trait_relax.alternative_model.fit, added_params_num, trait_relax.codon_data_info[terms.data.sample_size])); 
	
	// set the codon model again, inorder to be able to exract parameters for reporting from it
	trait_relax.latest_estimates = trait_relax.alternative_model.fit[utility.getGlobalValue("terms.global")];
	trait_relax.set_codon_model();
	
	// report the resluts of the alternative model fitting
	trait_relax.fitted.K = estimators.GetGlobalMLE (trait_relax.alternative_model.fit,terms.trait_relax.k);
	io.ReportProgressMessageMD("TraitRELAX", "alt", "* Relaxation/intensification parameter (K) = " + Format(trait_relax.fitted.K,8,2));
	
	io.ReportProgressMessageMD("TraitRELAX", "alt", "* The following rate distribution was inferred for branches under character 0");
	trait_relax.char_0.model_inferred_distribution = parameters.GetStickBreakingDistribution (models.codon.BS_REL.ExtractMixtureDistribution (trait_relax.char_0.model)) % 0;
	selection.io.report_dnds (trait_relax.char_0.model_inferred_distribution);
	
	io.ReportProgressMessageMD("TraitRELAX", "alt", "* The following rate distribution was inferred for branches under character 1");
	trait_relax.char_1.model_inferred_distribution = parameters.GetStickBreakingDistribution (models.codon.BS_REL.ExtractMixtureDistribution (trait_relax.char_1.model)) % 0;
	selection.io.report_dnds (trait_relax.char_1.model_inferred_distribution);

	// document the results in the json file
	trait_relax.document_alternative_fit();	
}


/**
 * @name trait_relax.perform_test
 * @usage requests input paths from the user and processes them into hyphy instances
 */
function trait_relax.perform_test() 
{	
	trait_relax.alpha = io.PromptUser("\n>Select the p-value threshold to use when testing for selection", 0.05, 0, 1, FALSE);

	parameters_num_diff = 1;
	if (trait_relax.site_propertions_freedom == "Yes") {
		parameters_num_diff = 2;
	}
	trait_relax.LRT = math.DoLRT (trait_relax.null_model.fit.log_likelihood, trait_relax.alternative_model.fit.log_likelihood, parameters_num_diff);

	// compute the bayes factors and the empirical bayes posteriors per site
	sites_bayes_measurements = trait_relax.compute_bayes_measurements(sitewise_blockwise_likelihoods, num_of_histories, trait_relax.p);

	console.log ("----\n## char_1 for relaxation (or intensification) of selection in association with a phenotypic trait [TraitRELAX]");
	console.log ( "Likelihood ratio test **p = " + Format (trait_relax.LRT[terms.p_value], 8, 4) + "**.");

	if (trait_relax.LRT[terms.p_value] <= trait_relax.alpha) {
		if (trait_relax.fitted.K > 1) {
			console.log (">Evidence for *intensification of selection* among phylogeny under character state 1 _relative_ to the phylogeny under character state 0 at P<="+ trait_relax.alpha);
		} else {
			console.log (">Evidence for *relaxation of selection* among among phylogeny under character state 1 _relative_ to the phylogeny under character state 0 at P<="+ trait_relax.alpha);
		}
	} else {
		console.log (">No significant evidence for relaxation (or intensification) of selection associated with character evolution at P<="+ trait_relax.alpha);
	}

	trait_relax.json [terms.json.test_results] = trait_relax.LRT;
	(trait_relax.json [terms.json.test_results])[terms.trait_relax.k] = trait_relax.fitted.K;
	(trait_relax.json [terms.json.test_results])[terms.trait_relax.p] = trait_relax.p;
	(trait_relax.json [terms.json.test_results])["codon sites to trait association"] = sites_bayes_measurements;
	(trait_relax.json [terms.json.test_results])["number of sequence optimization iterations"] = sequence_optimization_iterations_num;

	console.log ("----\n");
	
	selection.io.stopTimer (trait_relax.json [terms.json.timers], "Overall");

	io.SpoolJSON (trait_relax.json, trait_relax.json_path);

	return trait_relax.json;
	
}


/* ________________ TRAIT RELAX AUXILIARY FUNCTIONS __________________ */


/**
 * @name trait_relax.generate_character_likelihood_function
 * @param {Float} mu    						- character substitution rate
 * @param {Float} pi_0    						- frequency of state 0 in the character model
 * @param {String} lf_prefix					- string that holds the prefix of the likelihood function in the global namespace
 * @param {Dict} filter_name  					- dictionary holding a pointer to the character data
 * @param {Dict} tree							- dictionary holding the tree provided by the user
 * @usage generates a likelihood function of the character model given initial parameters
 */
lfunction trait_relax.generate_character_likelihood_function(mu, pi_0, lf_prefix, data_filter, tree) 
{
	character_initial_parameters = {
	 "global":{
	   "Substitution rate from character 0 to character 1":
	   {utility.getGlobalValue("terms.fit.MLE"): mu}
	  },
	 utility.getGlobalValue("terms.efv_estimate"):{
	   utility.getGlobalValue("terms.model"):{
		{pi_0}
		{1-pi_0}
		}
	  }
	};
	
	/* for improvement: since the empirical frequencies are estimates by default, the set_freq option runs over the empirical frequencies 
	with the values provided in the initial values */
	trait_likelihood_function = custom_functions.CreateLFObject_FixedBLs (lf_prefix, data_filter, tree, "models.binaryML.ModelDescription", character_initial_parameters, {utility.getGlobalValue("terms.run_options.retain_lf_object"): TRUE, "set_freq": TRUE, "return_lf": TRUE});
	
	return trait_likelihood_function
}


/* _____________________________________________________________________*/
/* Generates a rule map that maps each branch in he history to is		*/ 
/* corresponding label 													*/
lfunction custom_functions.generate_history_rules_map(history) 
{
	test_dict = {};
	reference_dict = {};
	model_map_guide = history[utility.getGlobalValue("terms.trees.model_map")];
	branch_names = utility.Keys(model_map_guide);
	for (i=0; i<Columns(branch_names); i=i+1) {
		branch = branch_names[i];
		if (model_map_guide[branch] % "char_1") {
			test_dict[branch] = "char_1";
		} else {
			reference_dict[branch] = "char_0";
		}
	}
	model_map = { "trait_relax.char_1.model" : test_dict,
				  "trait_relax.char_0.model" : reference_dict };	
				  
	return model_map
}


/**
 * @name trait_relax.wrapper_get_joint_likelihood
 * @param {Dict} args_dict - dictonary holding the arguments to call trait_relax.get_joint_likelihood with
 * @return {Float} log likelihood - the output from the call to trait_relax.get_joint_likelihood with the parsed arguments
 */
lfunction trait_relax.wrapper_get_joint_likelihood(args_dict) 
{
	mu = (^args_dict)[0];
	pi_0 = (^args_dict)[1];
	trait_lf_id = (^args_dict)[2];
	trait_filter_name = (^args_dict)[3];
	sequence_dataset = (^args_dict)[4];
	sequence_trees = (^args_dict)[5];
	histories_num = (^args_dict)[6];
	approximation_method = (^args_dict)[7];
	model_object_map = (^args_dict)[8];
	relax_initial_parameters = (^args_dict)[9];
	optimize_sequence_parameters = (^args_dict)[10];
	max_simulations_num = (^args_dict)[11];
	run_options = (^args_dict)[12];
	base_model_map = (^args_dict)[13];
	
	log_likelihood = trait_relax.get_joint_likelihood(mu, pi_0, trait_lf_id, trait_filter_name, sequence_dataset, sequence_trees, histories_num, approximation_method, model_object_map, relax_initial_parameters, optimize_sequence_parameters, max_simulations_num, run_options, base_model_map);
	
	return log_likelihood;
} 


/**
 * @name trait_relax.get_joint_likelihood
 * @param {Float} mu    						- character substitution rate
 * @param {Float} pi_0    						- frequency of state 0 in the character model
 * @param {Dict} filter_name  					- dictionary holding a pointer to the character data
 * @param {Dict} tree							- dictionary holding the tree provided by the user
 * @param {Integer} histories_num				- number of histories to consider in the character history approximation
 * @param {String} approximation_method 		- the approximation method that would be applied in the likelihood computation (integrating over all histories or averaging all to a single expected history)
 * @param {Dict} model_object_map  				- dictionary that holds the test and reference models that should be applied on the history's branches
 * @param {Dict} relax_initial_parameters		- dictionary the holds the initial sequence model parameters
 * @param {Bool} optimize_sequence_parameters	- TRUE if you wish to optimize the likelihood function over the sequence model parameters or not
 * @param {Integer} max_simulations_num			- the maximal number of simulations per branch before simulation failure is declared
 * @return {Float} log_likelihood	       		- the computed log likelihood
 * @usage simulates character histories, generates the joint likelihood function over these histories / the average history and computed / optimizes the likelihood function. must be a global function in order to have access to the joint likelihood function, which is generated in global namespace (solution based on estimators.bf with 'lfid' resulted in log likelihood -inf
 */
lfunction trait_relax.get_joint_likelihood(mu, pi_0, trait_lf_id, trait_filter_name, sequence_dataset, sequence_trees, histories_num, approximation_method, model_object_map, relax_initial_parameters, optimize_sequence_parameters, max_simulations_num, run_options, base_model_map) 
{
	/* for improvement: here, I re-create the codon model (RELAX) because it was deleted in the last iteration along with the last likelihood function */ 
	utility.ExecuteInGlobalNamespace("trait_relax.set_codon_model();");

	// initialize the input for the construction of the joint likelihood function
	joint_sequence_filter_names = {}; 
	/* for improvement: here, I am duplicating the data filter since the one from the former iteration was deleted along with the likelihood function */
	custom_functions.dup_data_filter("data_filter_0", sequence_dataset); 
	joint_sequence_filter_names[0] = "data_filter_0";
	joint_sequence_trees = {};
	
	joint_sequence_trees[0] = sequence_trees[0];	
	model_maps = {};
	model_maps[0] = ^ base_model_map;
	lf_formula = "'Log((1-trait_relax.p)*SITE_LIKELIHOOD[0]+trait_relax.p*((0+"; // add 0 in order to be able to use the same string concatanation for the first histories and the other histories
	
	// create the likelihood function instance for the SM procedure
	utility.ExecuteInGlobalNamespace("trait_relax.trait.model.mu_01 = " + mu + ";");
	utility.ExecuteInGlobalNamespace("trait_relax.trait.model.equilibrium_frequency_of.0 = " + pi_0 + ";");
	trait_relax.char_log_likelihood = estimators.ComputeLF(^ trait_lf_id);

	// initialize 0 and 1 durations along the tree per generated history, and the histories themselves
	histories_durations_dict = {};
	histories_dict = {};
		
	// run the TraitRELAX pipeline on histories_num character (trait) histories 
	for (h = 0; h < histories_num; h = h+1) {  
		 
		// generate a stochastic mapping and put it in the path labelledtree_path	
		history = custom_functions.generate_history(h, &histories_durations_dict, ^trait_lf_id, sequence_trees[0], pi_0, mu, max_simulations_num, run_options);
		
		// if the user chose to fit the alternative model to multiple histories -> add the history to the likelihood function
		if (approximation_method == "Multiple Histories") {
			
			// apply the alternative model on the history
			histories_dict[h] = {"id": history_id, "tree": history};

			// add the history to the likelihood function formula
			lf_formula = lf_formula + "+SITE_LIKELIHOOD[" + (h+1) + "]";
			
			// add he history to the sequence dataset 
			joint_sequence_filter_names [h+1] = "data_filter_" + h+1;
			/* for improvement: here, I am duplicating the data filter since the the likelihood function must be given a different data filter for each tree
			(i.e, history), in order to be able to delete it later */
			custom_functions.dup_data_filter(joint_sequence_filter_names [h+1], sequence_dataset);
			joint_sequence_trees[h+1] = history;
			model_maps[h+1] = custom_functions.generate_history_rules_map(history);
		}
	}
	
	// user chose to compute the likelihood over all the character histories --> include all of them in the likelihood function formula
	if (approximation_method == "Multiple Histories") {
		lf_formula = lf_formula + ")/" + histories_num + "))'";
	
	// user chose to average the histories into a single expected history    --> average the histories and use the expected history in the joint likelihood function formula
	} else { 
		expected_history_info = custom_functions.average_histories(sequence_trees[0], &histories_durations_dict, run_options); // compute the expected history
		custom_functions.dup_data_filter("data_filter_1", sequence_dataset) ;
		joint_sequence_filter_names[1] = "data_filter_1";
		joint_sequence_trees[1] = expected_history_info;
		model_maps[1] = custom_functions.generate_history_rules_map(expected_history_info);
		histories_dict[1] = {"id": expected_history_info_id, "tree": expected_history_info};
		lf_formula = lf_formula + "SITE_LIKELIHOOD[1])))'";
	}

	// generate and optimize the joint likelihood function (i.e, while optimizing the sequence model parameters)
	if (optimize_sequence_parameters) {
		trait_relax.alternative_model.initial_parameters = custom_functions.FitLF_FixedBLs(joint_sequence_filter_names, joint_sequence_trees, lf_formula, model_maps, ^relax_initial_parameters, model_object_map, {utility.getGlobalValue("terms.run_options.retain_lf_object"): run_options[utility.getGlobalValue("terms.run_options.retain_lf_object")], terms.run_options.proportional_branch_length_scaler: trait_relax.scaler, "custom_lf_formula": TRUE, "optimize_branch_lengths": FALSE});
	}
	
	// generate and compute the log likelihood of the joint likelihood function (i.e, while fixing the sequence model parameters)
	else {	
		trait_relax.alternative_model.initial_parameters = custom_functions.ComputeLF_FixedBLs(joint_sequence_filter_names, joint_sequence_trees, lf_formula, model_maps, ^relax_initial_parameters, model_object_map, {utility.getGlobalValue("terms.run_options.retain_lf_object"): run_options[utility.getGlobalValue("terms.run_options.retain_lf_object")], terms.run_options.proportional_branch_length_scaler: trait_relax.scaler, "custom_lf_formula": TRUE, "optimize_branch_lengths": FALSE});
	}
	
	trait_relax.seq_log_likelihood = trait_relax.alternative_model.initial_parameters[utility.getGlobalValue("terms.fit.log_likelihood")];
	
	fprintf(stdout, "* Sequence Log Likelihood = ", trait_relax.seq_log_likelihood, "\n"); // debug

	trait_relax.joint_log_likelihood = trait_relax.char_log_likelihood + trait_relax.seq_log_likelihood;
	
	if (run_options["return_extended_form"]) { 
		trait_relax.alternative_model.initial_parameters [utility.getGlobalValue("terms.fit.log_likelihood")] = trait_relax.joint_log_likelihood;
		return &trait_relax.alternative_model.initial_parameters;
	} else {
		return trait_relax.joint_log_likelihood;
	}
}

		
/**
 * @name trait_relax.set_mp_partition
 * @param {Dict} partition_info  - dictionary that holds the user sequence input (codon alignment and tree)
 * @return {Dict} return_set	 - mapping of the tree branches to the test and reference models
 * @usage classifies all the branches except for the first one to reference (used as some meaningless partition for the null model optimization) 
 */		
lfunction trait_relax.set_mp_partition(tree, trait_data, char_0_branches_names, char_1_branches_names) 
{	
	state_to_label = {"0": char_0_branches_names , "1": char_1_branches_names};
	mp_data = custom_functions.getMPTreePartition(tree, state_to_label, trait_data); // move to to he null section and change the branches selector accordingly
	mp_score = mp_data[0];
	mp_selected_branches = mp_data[1];
	return {"0": mp_score, "1": mp_selected_branches};
}


/**
 * @name trait_relax.set_base_partition
 * @param {Dict} partition_info  	- dictionary that holds the user provided tree 
 * @usage creates a base model map that maps all branches into the reference category
 */
lfunction trait_relax.set_base_partition(partition_info) 
{
	tree = ((partition_info["0"])[utility.getGlobalValue("terms.data.tree")]); // [utility.getGlobalValue("terms.trees.newick_with_lengths")];
	branch_names = trees.BranchNames(tree);
	model_map = {};
	char_0_dict = {};
	for (i=0; i<Columns(branch_names)-1; i=i+1) {
		branch = branch_names[i];
		char_0_dict[branch] = "char_0";
	}
	return {"0": char_0_dict};
}	


/**
 * @name trait_relax.map_all_to_reference
 * @usage creates a base model map that maps all branches into the reference category
 */
function trait_relax.map_all_to_reference() 
{	
	branch_names = trees.BranchNames(trait_relax.trees[0]);
	model_map = {};
	char_0_dict = {};
	for (i=0; i<Columns(branch_names); i=i+1) {
		branch = branch_names[i];
		char_0_dict[branch] = "char_0";
	}
	model_map = {"trait_relax.char_1.model" : utility.Filter (char_0_dict, '_value_', '_value_ == trait_relax.char_1.model_branches_name'),
                    "trait_relax.char_0.model" : utility.Filter (char_0_dict, '_value_', '_value_ == trait_relax.char_0.model_branches_name')};
	return model_map;	
}


/**
 * @name trait_relax.set_true_history_partition
 * @param {Dict} partition_info  	- dictionary that holds the user provided tree 
 * @usage creates a base model map that maps all branches into the reference category
 */
function trait_relax.set_true_history_partition(partition_info) 
{
	// process true history
	utility.ToggleEnvVariable ("GLOBAL_FPRINTF_REDIRECT", "/dev/null");
    ExecuteCommands('true_history_partition = trees.LoadAnnotatedTreeTopology.match_partitions (trait_relax.codon_data_info[utility.getGlobalValue("terms.data.partitions")], trait_relax.name_mapping);', {"0": trait_relax.true_history_path});
    utility.ToggleEnvVariable ("GLOBAL_FPRINTF_REDIRECT", None);
	
	return_set = {};
	tree_configuration = {};
    tree_for_analysis = (true_history_partition[0])[utility.getGlobalValue("terms.data.tree")]; 
	
	tag_test = "FG";
	tag_reference = "BG";
	
	
	utility.ForEachPair (tree_for_analysis[utility.getGlobalValue("terms.trees.model_map")], "_key_", "_value_", "
        if (`&tag_test` == _value_ ) {
            `&tree_configuration`[_key_] = utility.getGlobalValue('trait_relax.char_1.model_branches_name');
        } else {
            if (`&tag_reference` == _value_ ) {
                `&tree_configuration`[_key_] = utility.getGlobalValue('trait_relax.char_0.model_branches_name');
            }
        }
    ");

    return_set + tree_configuration;
    return return_set;
}


/**
 * @name trait_relax.compute_bayes_measurements
 * @param {Matrix} sitewise_blockwise_likelihoods - matrix holding the site likelihood per codon site per history
 * @param {Integer} histories_num  		  		  - number of histories
 * @param {Float} dependent_propertion  		  - estimated proportion of sites whose evolution depend on the trait evolution
 * @return {Dict} site_bayes_measurements         - a dictionary that holds the bayes factor per site and and empirical bayes posterior per site vectors
 * @usage computed the byes factor and empirical bayes posterior measurement for each codon site
 */	
lfunction trait_relax.compute_bayes_measurements(sitewise_blockwise_likelihoods, histories_num, dependent_proportion) 
{
	sites_number = Columns(sitewise_blockwise_likelihoods) / (histories_num+1);   // the additional block is the independent case block (i.e, tree)
	sites_bayes_factors = {};
	sites_bayes_potesriors = {};
	for (i=0; i<sites_number; i+=1) {
		independent_case_likelihood = sitewise_blockwise_likelihoods[0][i*(histories_num+1)];
		dependent_case_likelihood = 0;
		for (j=1; j<=histories_num; j+=1) {
			dependent_case_likelihood = dependent_case_likelihood + sitewise_blockwise_likelihoods[0][i*histories_num+j]; // sitewise_blockwise_likelihoods is ordered by sites and then by blocks (=trees)
																													   // for example: say I have two sites and 3 trees: position 0 corresponds to (site 1, tree 1) 
																													   //										   		 position 1 corresponds to (site 1, tree 2) 
																													   //												 position 3 corresponds to (site 2, tree 1) 
		}
		dependent_case_likelihood = dependent_case_likelihood / histories_num;
		sites_bayes_factors[i] = dependent_case_likelihood / independent_case_likelihood; // compute the bayes factor of site i
		sites_bayes_potesriors[i] = (dependent_case_likelihood * dependent_proportion) / (dependent_case_likelihood * dependent_proportion + independent_case_likelihood * (1-dependent_proportion)); // bug here
	}
	site_bayes_measurements = {}; // first line is bayes factors, second line is empirical bayes posteriors
	site_bayes_measurements["bayes factor per site"] = sites_bayes_factors;
	site_bayes_measurements["empirical bayes posterior per site"] = sites_bayes_potesriors;
	return site_bayes_measurements;	
}		

		
/* ______________ RELAX AUXILIARY FUNCTION (DEEP COPY) _______________ */

lfunction relax.DistributionGuess (mean) 
{
    guess = {{0.05,0.7}{0.25,0.2}{10,0.1}};

    norm = + guess[-1][1];
    guess_mean = 1/(+(guess [-1][0] $ guess [-1][1]))/norm;
    return guess["_MATRIX_ELEMENT_VALUE_*(guess_mean*(_MATRIX_ELEMENT_COLUMN_==0)+(_MATRIX_ELEMENT_COLUMN_==1)*(1/norm))"];
}